# JS进阶课笔记
## 第一节课：你好，web应用
不讲代码，带着做——讲代码容易有惰性，不会自己主动思考
1、为什么要学webapp？
可以把我的想法实现出来，webapp可以做出来一个产品，真正的产品，在互联网上给人用的产品——做一个五脏俱全的小产品，比如个人博客：里面可以发布内容、评论、分享、收藏、登陆、注册、注销等等。有了一个内容平台，之后就可以渐进式的增加功能，比如打卡什么的
学完webAPP后自己做一个产品——用自己的服务器，做一个前端管理界面，然后使用小程序作为输入端，上传到网页端存储数据。后期还可以加上自动分析数据、提取数据的功能————直到实现创业模式的思维转变（徐原话）
个人如何切入市场并站住脚呢？先从细分市场入手，服务小部分人，然后逐渐提升功能和服务人数。——做一个能用的webAPP产品。

2、课程的学习方式
以徐高阳的教材为主，围绕着“小白学编程”这个网页，教材：learn-webapp-guideline。每周完成一个点，以“发现”里面的文章为辅。在线课主要聊技术，讨论技术，课后再研究具体的代码。

3、从外部去理解webAPP，不仅仅是page页面，还能提供data服务。做成什么样子完全取决于自己。
类比：webapp就是一个函数：三要素——函数名、返回值、参数。一个函数就像一个黑盒子：传输进数据，出来一个结果。webAPP也是这样：给他一个请求，返回一个响应。————request 请求、response响应这两个词非常重要。
request=》http，http是客户端往服务端发送请求的一种渠道，http是一种协议，ftp也是一种协议。https是更安全的协议。=》为了将信息完整的发送给另一方。

4、webAPP所能提供的东西：
Webapp所能处理的请求，返回一个怎样的响应，这就是webapp的价值。处理请求可以通过http、data、
当使用http提供数据的时候，要想清楚提供什么数据：图片、文本、音频视频、数据库数据等等。要怎么处理数据、怎么把数据返回到客户端给客户。
把webapp理解成一个服务，基于nodejs的express，开发一个中间键，当有请求到来的时候，分发请求
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/DD416247-063D-429A-AFB2-E4C68D8D6786.png)
这是一种非常高效的方式，起到一个衔接作用。中间层的目的是屏蔽底层业务逻辑，就像jQuery，屏蔽了原生dom，简化了操作。
对数据的四种基础方式：增删改查。后期使用数据库时主要就是这四步。难点在于更加高效的处理。

5、接下来一周的任务：
跟着教程一步一步做。本周只做到第七节即可。下周三上课前必须完成7节。同时围绕着前七节不断拓展深挖具体的知识。
每个小节都有一个事例，事例的代码都在GitHub上，跟着一步步的迭代，优化代码，思考为什么要优化代码。
使用代码比较工具，看老师每个小节加的代码的原因，为什么要这么加。

6、备案：
域名——备案——服务
首先在服务器开一台机器，然后在电脑上通过公网的ip地址，访问到机器，链接自己的电脑和机器。在中国，域名是和公网ip地址绑定，公网ip再链接服务器。域名不能直接链接服务器。
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/D6A0E5E9-EB77-49E8-9E64-BB67DA541E7A.png)
端口：只有80端口是默认的，小程序和公众账号必须用80端口。ubuntu用16.04，64位。
## 第一节课作业：
配置好supervisor后，只要先进入first_app文件夹，再启动项目即可，目录如下：
```
cd /Users/johnsmiths/Documents/xswebapp/first-app
npm run auto-start
```
开发WebApp需要的做什么？
1. > 处理路由能力。一个网站都会提供多个地址的访问能力，比如https://xinshengdaxue.com 可以访问新生大学的主页，https://web.xinshengdaxue.com/home/lessons 可以访问所有课程页面。一个地址代表一个访问路径，一般称为路由，WebApp必须具备分析不同路由的能力。
2. 构建页面能力。WebAPP提供页面是最基本的能力，构建HTML就是开发中最重要的工作，也是最繁重的工作。正因为繁重，在技术才才会采用前后端分离的开放模式，提供HTML页面的client端由前端工程师完成，提供数据的server端由服务端工程师完成。
3. 操作浏览器能力。浏览器提供了很多功能，常见的有cookie和storage。cookie和storage都是浏览器的存储技术，利用这些技术可以在浏览器端缓存一些必要的信息。这些技术都可以通过查阅HTML5 API文档获得。
4. 提供页面和数据能力。如果前后端一体化开发时，WebApp的server端必须提供页面和数据，以供client端可以构建丰富的页面，以及存储用户操作带来的变化数据。
5. 持久化数据能力。server端存储数据是基本的能力，一般采用第三方数据库来完成。常用的数据库有mysql，sqlite，mongodb等。开发中小型项目，选择一个最熟悉的数据库即可。
- - - -
目前Express已经安装在Users_johnsmiths_Documents_xswebapp_first-app中，Express和tp5一样都是一种框架，自带封装好的便利函数，不同的地方在于除了自带框架还集成了Apache功能，可以通过终端命令开启一个本地服务器。
对于路由，之前小程序商城项目中已经接触过不少了，路由就是通过绑定不同的地址，将输入的网页地址导向不同的页面。
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/route-map.png)
就像这幅图一样，不同的地址导向不同的页面。
app.js是一个全局的配置文件，在这个文件中，首先新建一个路由的变量，如var index = require('._routes_index’);，将index文件从路由的文件中引入，然后再使用这个变量：app.use('/', index);。
在routes文件下下，index和users的内容并不相同
index是：
```
/* GET home page. */
router.get('/', function(req, res, next) {
  res.render('index', { title: 'Express' });
});
```
Users是：
```
/* GET users listing. */
router.get('/', function(req, res, next) {
  res.send('respond with a resource');
});
```
但是将users里res.send发送的内容更改为index的内容后，依然可以正常访问并将页面的内容显示为index的内容。
添加一个新的路由和页面，基础操作应该是这样的：
1. 在路由文件夹内新建一个处理路由的js文件
2. 在显示页文件夹内新建一个对应的页面ejs文件
3. 在app.js中新建一个变量，并将这个变量跟routes下面那个目标文件关联：var 新建=》app.use引入
4. 在routes文件夹下将目标文件中的显示ejs文件返回给用户
- - - -
## 第二课，选择一个web架构
注意node版本，nvm list可以看见电脑上已经安装的node版本。^符号是大于等于的意思。
是想把 WebApp 设计成只提供数据的一个服务？还是一个提供页面的客户端？比如 vue-hackernews-2.0，这么一个前端的项目，为什么会依赖 Express 这个后端项目？因为所有的页面都是从服务器获取的，浏览器可以从一个服务器获取页面，然后从另一个服务器获取数据。这样一来前后端就解耦了。
Express在GitHub上有，应用非常广，基于nodejs最成功的项目。
为什么要全局安装Express，而不是当成第三方的库？全局安装 Express 的话，可以方便地在各个地方构建一个默认的工程项目，为开发者搭建好了基础的脚手架，这样就不用从零开始了，会方便很多。框架性的项目要看解决了什么，Express既可以全局安装在电脑里，可以当成第三方的库使用。——全局安装后可以默认构建一个完整的工程。
运行项目的时候为什么要加debug？在启动项目的时候给项目传递一个参数，参数的内容可以增加，增加的内容是可以再项目里读到，并使用的。如果不写就使用默认的内容——DEBUG=first-app:* npm start，在 npm start 前面的命令，是为了在项目启动时，向 process.env 传入参数。
DEBUG=first-app:* PORT=3001 ABC=123 npm start 就传入了三个参数。
一个webapp工程应该是什么样子的结构这个问题很难。因为跟开发经验有关，也有交流成本有关。
一个工程最重要的是什么？入口文件。入口文件就像是电脑的开关。
Nodejs项目最重要的是什么？package.json——在这里面能够找到“开关”——项目版本号、脚本、依赖包等等。
依赖包（第三方库）决定了什么？功能
Bin文件是什么？可执行文件，就像Windows里面的exe，也可以理解为入口文件。
Public里面放的是前端可执行文件。
Routes是分发运行执行的桥梁。
Views并不是必须的，也不是最重要的。如果页面只提供数据，就可以不要views
- - - -

![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/85876B17-E812-4CA1-9B35-8F72D6ED2F6A.png)
Bin文件可以简化到这种程度，这里就是bin文件的主干，抓住主干、抓住主要矛盾就是理解了这件事。包括Express官网都把这几行代码放在首页，显示重点。
- - - -
学习路由的核心点：这是一个注册机制——在app内执行了很多注册机制的代码，注册了后才能进行分发。
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/6B4780E4-C4CF-4B48-B421-97DB83ACF0E8.png)
当_，就分发到index，当_users，就分发到users。这里是按上下顺序分发的，就像之前小程序商城的那一节课程一样。如果匹配不上，就会触发“next”机制——从一个模块流向下一个模块。app.js是顺序执行的，把app.use('/users', users);加在最后，就404。
就像js的变量提升一样，先登记，等数据进来后再进行响应。
- - - -
作业：start的两种方式：npm run auto-start和auto-start有什么区别？
- - - -
## 第三课：一个请求对应一个路由
### npm start VS npm run start:
两者其实是等价的，而工程师通常都会尽量寻找能够提高自己效率的方法，那么一些高频的操作其实就可以设置快捷键，比如 npm start 就等于 npm run start。Npm就是作者设计的一个快捷键
另外 npm i 也是和 npm install 等价的，省去额外敲 6 个字母的时间，完美！哈哈。
再以老师解决徐杰同学问题的过程为例，在帮助别人或者解决自己问题的过程中，往往能够学到新的知识，还会启发新的想法，经常这样多去思考，能够让自己更快地成长。
学习不是追求答案，而是学习追求答案的过程。
- - - -
### 理解 Express Route
Express 的路由，可以理解为工地进货各种物料。

一车物料通过工地大门（域名_IP + 端口）进入工地之后，首先由工长 A （根目录 '_'）检查是否自己要的物料，是的话就进行自己的处理（route_index.js）；不是的话就由工长 B （_posts）检查，是的话就进行自己的处理（route/posts.js）；这样依次检查，最后都不符合的话，那就要进行错误处理（app.js 最后两个函数）。
路由是如何匹配的呢？依然以工地进料为例，各个工长都只负责一类物料，比如工长 A 只负责接收钢材，B 只负责接收水泥，等等。
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/04F63106-27C1-4E70-91CD-D22F0D790648.png)

在 Express.js 中，搞定了 app.set() 和 app.use()，就搞定了 Express.js 一切。
把路由想象成分配资源请求的一个人，不断的分配各种数据
如果路由特别多的话，就会分服务，把不同的路由类型分开。
- - - -
### 解读 app.js
一句话：app.use 会处理所有的数据，一步步往下，直到某个模块接管，最后还要有一个容错的处理。
可以删掉 app.js 中的容错处理，然后猜测 Express.js 是否也会做一个容错处理。
app.js 中删除掉所有路由相关的代码之后，访问根目录的话，页面会返回 Cannot get /，说明这是框架本身返回的。
然后开始添加一个工长 A：
```
app.use('/', function(req, res, next) {
    res.send('i got it');
});
```
这样就可以访问根目录。
再添加一个工长 B：
```
app.use('/posts', function(req, res, next) {
    res.send('i got it: posts');
});
```
但是这个时候，访问 /posts'，显示的还是根目录的页面！（待确认，这个留作作业。）
app.js 的路由设置之前的一段代码，是 Express 的中间件，作用是什么？是为了分析数据、整理数据。
这么一来，就说明 Express 处理请求是从第一个 app.use() 开始的。而路由设置之前的那段代码，默认匹配的是所有路由！也就是等价于 app.use('*', logger('dev')); 这样的代码。
为什么后面的示例，能够用 req.body.title 这样的数据呢？就是因为前面中间件实现的那一部分功能。
既然每次光是中间件就要执行六步处理，那很多人访问的话，会不会很慢？
为了提高工程师的开发效率，增强代码的健壮性，应该怎么做？那就要实施模块化/封装！
所以不用担心这么多中间件不会影响效率，因为所用的中间件一般都是同类最好的，效率是最高的，得到最多人的认识的，所以才会放在框架中让人用，所以不用担心增加几个中间件是否会拖慢运行速度。
另外，一个个路由是怎么接管客户端的访问呢？就是靠 响应。
- - - -
### 解读route/index.js
router.get() 方法中的 res.render() 这类方法（res.send() 等等，这个留作作业）就是处理响应用的，比如在 route/index.js 中，router.get() 方法里不做任何操作，直接 next() 的话，由于 /users 这个路由不匹配，所以会直接 404。

注意：有时候同学们会在正常的处理语句之后加上一个多余的 next()，这样浏览器能正常显示结果，但是后端会提示错误。要避免这种情况，一个请求只对应一个路由！
- - - -
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/1D95C8D0-96AB-4BCA-85DE-913FEDF86E96.png)
这是Express的中间层，不能随意调换顺序，调换后首页会无法访问，报错，但是其他的路由可以正常访问。
中间层的目的是用来分析、整理数据。意味着Express处理的所有路由是从第一个开始处理的，虽然表面上没有匹配路由，但是实质上匹配所有的路由。实际上等价于下面这张图
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/593B7829-A851-4BC4-B9C0-47FC2A5E76DC.png)
在把数据分发时就进行数据处理。
中间层接管数据的方式=》响应
响应有很多方法：(作业）
```
res.render()
res.json()
res.end()
res.send()
```
作业8-13
- - - -
## 第四课：化繁为简的视图引擎
作业1：响应请求的函数区别是什么？
res.render()：render翻译成“渲染”，即view + data = html。
res.json()：给一个json数据。json格式是js处理起来最得心应手的，因为json === 对象。
res.end()：表示请求结束，不用结果。如res.end(‘success’)、res.end(0)、res.end()等。
res.send()：可以发送一个数据过去，也可以嵌入一个单行的HTML。
作业2：
render
首先说 render()，渲染的是什么？在 Express中，一个 view 加上 data 就能够得到一个 html：view + data = html。
将数据传入视图模板中，然后 Express 就会渲染出一个 HTML 页面。
是否要用该方法，取决于是否用 Express 提供的视图引擎。
JSON
客户端和服务端服务端进行数据交互，用 JSON 是最合适的。
JavaScript 处理 JSON 是非常得心应手的，为什么呢？因为 JSON 就是对象。不过 JSON 是一种特殊的对象，它只有属性，没有方法。
Express => 基于 Node.js => 基于 JavaScript 语言，所以 Express 也提供了对 JSON 的支持。
end
只是表示处理完毕，不会给结果。服务端收到此命令，知道处理结束。
比如 res.end('success')、res.end()。
send
这个方法可以用来传输数据，可以传输单纯的字符串，也可以传入 HTML 代码，这个时候的效果就和 render() 一样了。
如果可以自己组装 HTML 的话，写代码的自由度就更高了，从而能够在一定程度上脱离 Express 这个框架的限制。
上次问题二：路由解析
app.use('*') 会匹配所有路由，app.use('/') 则只匹配根目录。
而路由中依次有两条 app.use('_') 和 app.use('_users') 时，即使访问后面这个路径，依然匹配的是前面这个路由。

本次课程：路由（route）
Router 本身就是 Express 内置的一个中间件，Express 在处理所有路由的时候，都交给 Router 这个中间件，所以在 app.js 中才可以用 app.use('/', index) 这样的语句把 / 路径交给 index 这个 router 对象处理。
在处理请求时，HTTP 有各种方法：get_post_patch_put_delete，一个客户端如果发的是 get 请求，如果不能用路由处理 get 请求的话，那就很不合适了。
既然浏览器默认的 HTTP 方法是 get，那么 post 方法就没什么用了么？并不是。

对于同一个路由，可以用 get 和 post 方法作出不同的响应。
比如
```
 GET /posts 可以处理成获取文章
POST /posts 可以处理成创建文章
DELETE /posts 处理成删除文章
PUT /posts 处理成修改文章
```
PATCH /posts 也可以处理成修改文章，但是 put 和 patch 是有不同的，那么是否能够利用好这两种方法呢？
Router 的这种能力，是 Express 的另一大利器：app 所不具有的。
那么任何路由都要写这么多方法么？没必要。要结合自己的业务来决定要用哪些方法。

Router 还有一个 all 方法，它什么都接受。

如果在处理 / 这个路由的 JS 文件 index.js 中，router 处理了 /posts，而 posts.js 也处理了 /posts 路由，那么 /posts 这个路由就会被 index.js 抢先处理，posts.js 是处理不到这个路由的。
还可以用下面的方法进行区别处理：
```js
app.use('/', function (req, res, next) {
    if () { ... }
    else { ... }
});
```
中间件截留数据的目的是什么？是对数据进行重新组装、封装等等。

本次课程：模板引擎（ejs）
EJS 并不是 Express 创造出来的，只是在设计架构时兼容了 EJS 的应用。所以说 EJS 并不是 Express 最重要的一个必需品。
所以在 app.js 中设置了 app.set('views', ...) 和 app.set('view engine', ...)，才能使用 EJS 这个模板引擎。
如何手动引入EJS？
```js
// index.js
var ejs = require('ejs');
var path = require('path');
var fs = require('fs');

router.get('/', function() {
    // 手动读入模板文件
    var content = fs.readFileSync(path(__dirname, '../views/index.ejs'));

    var pathString = path.join(__dirname, '../views/index.ejs');
    // 手动渲染引擎
    var html = new EJS({url: pathString}).render({title: 'Hello World'});
    res.send(html);
});
```
总的来说，Express 只是对 EJS 这个引擎进行了封装，自己完全可以脱离开 Express 来直接使用 EJS。

那么，下面这行代码和上面一大段代码就是等价的，这样一对比，下面这种形式的便利之处就出来了，就是因为它非常简洁。
```
res.render('index', {title: 'hello world'});
```
进一步来说，EJS 的核心在于 <% %> 这样的代码。
```js
// index.js
router.get('/', function() {
    res.locals.title = 'xugaoyang';
    res.render('index');
});
```
上面这段代码的效果，和默认示例的效果是一样的，也能把 title 参数传进去（哦，这个 title 是网页标签）。
所以访问的不只是 render() 带进去的参数，还有 res.locals 里面的参数，这样一来，其实就可以在 locals 里面带很多参数了！
另外，res.render() 只能往指定页面传入数据，如果要往所有页面都传入数据的话，就应当往 res.locals 之中传入数据，这样所有页面就都可以使用这些数据了。
加餐：页面如何渲染 markdown？
可以安装并引入 markdown-it 这个包，这个时候就可以把页面渲染成 markdown 的样式了。可以在后端渲染，也可以在前端渲染。
```js
// index.js
var markdown = require('markdown-it');

// index.ejs
// 此处自己揣摩代码，哈哈
```
题外话
关于选用的 MongoDB 数据库，这款数据库其实是非常适合用于博客、论坛这种内容性的数据库的。所以大家不用在意为什么别的都用的 MySQL、SQLite 之类的数据库。
8~13节都学完的同学，再回过头复习一下之前的知识点，不要图快。
课程结束后，也要坚持学习！
课后题
app.locals 和 res.locals 有什么区别？
- - - -
## 第五课：流动的数据流
保留字：不管编程语言怎么发展，都会有一些保留字不能用来当变量，比如defined。预留关键字的目的是为了这门语言未来的发展。
看一个nodejs项目应该先看package.json可以先看清楚项目的说明。
Express可以全局安装在电脑里，因为他是一个架构型项目，可以生成一个工程or项目，就像是工地里的脚手架。在这个脚手架上做项目可以节省开发webapp的成本。——一个脚手架里有：
```
Bin/www
App.js
Views
Public
route
```
在这个基础上去添加代码。接下来梳理Express的架构：
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/D14A9EFF-8C7E-4D24-8267-62396670653B.png)
所有的数据都是从上到下进行分发的。最下面才是处理具体逻辑的。在这个过程中最重要的是next、res、req。
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/A3B2C538-21CC-4CA8-BE7B-88212FC0D7BC.png)
把传进来的无规律数据处理成req对象和res对象。
Req是用来拿数据的。res是用来响应数据的。上节课说的render/send等等。
- - - -
Express 执行流程：
从 www 开始执行。然后加载 app.js。app.js 中会有各种各样的中间件。
接着通过“路由”这个中间件，将请求分发到对应的路由上，比如 index、users。这个时候，才是真正要去实现逻辑的地方，路由将请求传给模板文件或者进行其它的处理，然后将请求返回。
还有一个非常重要的，就是 next。除了 next，还有很重要的就是 res 和 req。
用户发进来的请求，都是散漫的。而工程师就要把用户这些散漫的数据，统一抽象到 req 这个对象里。把传入的数据处理完成之后，再根据实际需求，把数据抽象到 res 里面，返回给用户。
简单来说，就是：
* client 发数据。
* Express 把请求数据封装到 req：比如 req.body、req.query，这些都是封装进来的数据。
* Express 对数据进行对应的处理。
* Express 把响应数据封装到 res：比如 res.render、res.send 这些用于处理响应的方法。
而不管是上面哪种处理，都需要 next —— 这就是它的重要之处：将上一步的处理结果交给下一步。
- - - -
路由：
通过老师的演示可以看出，每一次的请求都是从上往下依次找一遍，所以访问 _posts 时，会先在 / 的 /api_posts 里面找一下，不匹配，然后再去 /posts 中找，找着了，OK，处理路由。
```js
app.use('/', function (req, res, next) {
    console.log('process 1 = ' + req.path);
    next();
}, page);

app.use('/posts', function (req, res, next) {
    console.log('process 2 = ' + req.path);
    next();
}, api);
```
API 一般都是用来提供数据的，可以搭配 res.json()、res.send() 来使用。
老师的示例中，将 page 与 api 分离开来，各司其职，修改其中一个功能也不会影响到另外一个功能，这是一种很好的开发习惯。
为什么要命名为 route.page.js？因为这样很形象，一眼就能看出来文件的作用，而且也便于处理文件。

题外话:
为什么 app.js 中，比如路由这里的代码没有 req、res、next，也能正常往下执行呢？
因为路由文件中，用的就是 Router 对象，而框架中的这个对象，会将传入的请求用 HTTP 方法处理完成之后，再用里面的 function(req, res, next) { ... } 将请求往下传。
这样的一种处理流程，能够让开发者更关注于业务逻辑，而不用太关注于琐碎的流程处理。
两个路由文件中导出的都是 router，不会冲突么？
因为 JS 是一门函数式编程语言，不管导出的是什么对象，本质上处理的都是一个个的函数，而这些函数之间不会有冲突，因为大家各司其职。所以两个路由文件处理的是不同的路由，是两个不同的函数，因此即使导出的都是 router 也不会冲突。

渲染时机:
在浏览器中请求 localhost:3000，Express.js 可以在服务端渲染生成 index.html 然后返回浏览器。服务器通过 EJS 这样的模板引擎来渲染 HTML，这样渲染工作就在服务端完成了。
还有一种情况：返回的 HTML 文件中的 script 标签里包含了 JS 文件，该文件向后端请求数据，获取到数据之后，利用 Vue 在前端将数据渲染成页面上的内容，这就是客户端渲染。

数据库之争:
json-server 并不是数据库，可以实现简单的数据存取，比如做一个打卡程序。而数据库是用于查询的，比如要从百万、千万条数据中查询，这个时候就需要用数据库了。

为什么要用 JSON？
因为在客户端和服务端之间传递数据时，JSON 比较方便。但是 JSON 相对来说，流量会用得多一些。不过现在的网络带宽让大家已经不用太关注流量了，所以 JSON 目前支持非常广泛。
- - - -
## 第六课：丰富多彩的中间件
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/793BDFB0-F5CD-4542-8606-AA7A33D1BB33.png)
Express就是一堆由中间件组成，输入data1，输出data2，再输入路由得到data3。
- - - -
API有两层意思：
1. 接口：只要能拿到数据的都可以被称为接口。
接口编程是很重要的，通过api来协作。
免费的mongodb软件：Robo 3T
- - - -
## 第六课 - Express.js 及 MongoDB
### Express 的重点
只要把回调函数设置好，等待调用就可以了。
最重要的一个回调函数：app.use()。
```
// 只讨论 data
data1 => 中间件 => data2 => Router => data3 => 错误处理 => data4
```
Express 的重点，就是中间件、路由这两大部分。

### API
API 涉及几个角色：作者，服务个体，端。这三者的价值不一样。
* 作者：假如三个人合作开发一个 WebApp，A 负责 app.js（控制了整个 WebApp 的主干），B 负责 router.page.js，C 负责 router.api.js。A 向 B 申请调用某个资源，B 则告知 A 调用某个 API 即可。这个时候，API 就是一个函数。这三者都属于同一个 WebApp。
* 服务：设计 WebApp 时，往往需要调用数据库，这个时候需要通过数据库的接口——API 来获取数据，这就是在调用外部的服务了。
* 端：比如前端的 Vue 通过 HTTP 请求向 WebApp 获取数据，也是可以用 API 的，这就是前端在向后端获取数据。
接口编程是软件开发过程中非常重要的一部分。

### 安全性
任何安全性的检查，客户端可以不做，但服务端都是必须做的！
如果要在前端检查数据的合法性，就要在传入数据库之前执行，对于不合规的数据都要阻止。

### 数据库
在设计应用时，往往都要存数据、操作数据。
Express 不仅提供了一套库，还提供了一套在终端操作的指令，能够方便用户在终端迅速创建脚手架。
MongoDB 也是如此，会运行一个 server 和一个 client。client 会提供一系列操作集，但是这个操作集不太好操作，开发者就会开发 mongoose 之类的库，对 MongoDB 的底层操作进行封装，提供易用的指令，来方便用户进行操作。
像 MongoDB 之类的很多语言，官方都没有提供 IDE，而只是提供了终端命令来操作。所以开发者都应该学好终端操作。
```
$ mongod --dbpath ./db # 启动服务端
$ mongo --host 127.0.0.1 --port 27017 # 客户端连接服务端
```
MongoDB 非常方便的一点就是，在 Schema 中只需要增加属性，就会自动新增字段，非常方便。
这个功能是如何实现的呢？每次通过 JS 连接 MongoDB 时，都会执行 Model 里面的代码，从而可以增/删字段。
希望一个同学能将 MongoDB 常用的操作整理成一篇文档：增删改查。如何通过 mongoose 的代码操作数据库，如何通过终端指令操作数据库。
核心：方法（add_find_delete/modify）+ 参数（条件：年龄大于 18，选项：只看 100 条，callback）。

### DEBUG 指令
Express 中引入的中间件都是很重要的，要一个一个去看！
Express 在 GitHub 上所开源的项目也都是很棒的，大家也要都看看。
未来可以在群里组织大家这样学习：一周搞定一个 Express.js 的中间件。
DEBUG=express:server 表示只在控制台输出 server 这个 debug 变量的日志。

### UserAgent
前面讲过，中间件过滤出来的都是结果数据，那么引入了 express-useragent 这个库，就会将 useragent 数据放到 req 中。
- - - -
## 第七课：提交数据
箭头函数是函数式编程特别重要的一块东西。不要想得太复杂。以前的数学里面，函数就是 y = f(x)。写成 JS 代码，就是 var y = function(x)。是不是很像？
函数式编程就是数学运算的一种方式。
函数式编程，本质上就是数学运算的一种方式。对于一个数学公式，给定一个输入，必定有一个输出与之对应。那么程序中的函数，如何保证给定一个输入必定有一个输出？此处略去一万字。
* 函数式编程：定义好流程，用户只需要往里面填数据即可。
* 结构式编程：需要用户照顾好整个流程。
箭头函数其实很简单的，可以理解为就是为了省略 function 这个关键字，但它的本质其实不止于此。现在先不深挖了。

app.use('/', page) 这个代码，既然可以改写成下面的形式，那能不能进一步拓展，把很多个 app.use() 都放到一个里面？可以的。
```js
app.use('/', function(res, req, next) {
    console.log('1234');
    next();
}, page);
```
不管各个中间件用什么方式写，如果其中的一个中间件挂掉了，如果没有妥善的异常处理，那么整个程序就挂掉了！这样的中间件就是渣渣，千万不要用这样的中间件。
所有的代码都会出错，所以中间件一定要有一个异常处理机制。要么中间件自己给处理掉了，要么就调用 next(err) 交给 Express 处理，因为这些中间件都是为 Express 写的嘛！
作业中有几个要点：中间件出了问题，进程可能就被挂住了。所以必须要有个机制能报错or进行下一步。

服务端如何高效地构建页面？EJS 算是做了一些改进，但是还不够好，于是就有了 Express-Ejs-Layouts，这样还是治标不治本。于是就有了 Vue/React，它们站在更高的层次上来解决页面构建的问题。

路由的新玩法:
一个 URL www.baidu.com/x/y?id=123 包含三部分：www.baidu.com 是域名，_x_y 是路径/路由，?id=123 则是参数。
Post 请求是一个比较安全的请求，所以可以把请求内容放到请求体（body）之中。
而不管路径、参数和 body 是什么，经过 Express 中间层处理之后，就会映射成对应的内容 => 路径被映射为 req.params，参数映射为 req.query，body 则映射为 req.body。这样就拿到了一个请求的所有数据，然后就可以为所欲为了。这就是中间件的魅力——把数据整理好了，我们就可以直接用了。
三大金刚：请求都封装在了 req 之中，响应都封装在了 res 之中，流程处理则都交给 next() 来做，这就是 Express 框架厉害的地方。
那么为什么 Express 能够把 _posts_create 解析到 posts/:tag 这个路由中呢？

题外话:
微服务：将大服务独立成一个个的个体，互相关联起来。一个坏掉，不会影响其它服务，减轻了运营维护的压力。
函数服务：一个函数就是一个服务。以美图秀秀为例：为什么一个模板不能对应于一个函数服务呢？用户传入一张图片，应用一个模板，就执行一个函数，实现这个效果。

作业：21-27全部做完。

Weex：以技术为切入点，这是阿里学vue的一个跨平台解决方案。可以关注这个项目，做出贡献，得到阿里的关注。主动寻求弯道超车的机会
- - - -
## 第八课：持久化储存
Obs直播开源软件，有一个配置的导入，直接复制自己的配置，方便直播

过一遍22节十个问题：
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/B26AA22D-83C9-43BC-AE37-98EA4E36F682.png)
1. 1
2. 核心，项目的配置文件。项目运行起来后就不需要package了。
3. 课程一开始就讲过，WebApp 的重要功能之一就是处理路由。
为什么说它是 Express 的中间件呢？因为` app.use('/', page); `这种格式就是中间件的使用方式。
比如到 sample-18 的时候，page 和 api 这两个路由就已经有十多个具体的路由处理代码了，将页面路由和 API 路由分离，才更加方便，更好管理。
路由提供的各种功能，都是为了满足各种丰富的需求的。。
4. 1
5. 上节课说的非常深，贯穿整个webapp的生命周期。
6. 1
7. Express不一定必须用ejs，还能用其他的。
8. 课上说过。
9. 练习里有
10. docker未来能解决很多层次的东西，必须花时间研究

柯里化：[Currying - Wikipedia](https://en.m.wikipedia.org/wiki/Currying)
ramda：http:ramdajs.com/docs/#cond

预习promise
- - - -
Js的上下文：
HTML 文件在浏览器中加载完毕之后，就会执行 script 标签中的脚本。
而 JS 脚本在执行前和执行时，有一个“上下文”（context）的概念。可以说上下文是环境给出的可以用的一些东西。
在执行脚本之前，浏览器已经提供了一个环境，环境里面有一些对象可以操作。这些对象，就叫上下文。
JS 脚本的上下文，一部分就是浏览器提供的 window 对象。另一部分就是引入的第三方库（比如 Vue.js, Axios.js 等）。

数据流中为什么要传递 req、res 和 next ？
这三者贯穿了整个项目中的所有中间件，就是这三者提供了所有的能力：接收请求、返回请求、继续往流程的下一步走。

代码设计思想
在 app.js 中调用 lib.js，就可以执行其中的 add() 这个工具函数，来执行加法。
各种代码都是工具，工具有大有小，能力有大有小。
有了基础函数 add 之后，就可以用它来定义各种各样的函数，自增 1，自增 2，等等等等。这就是函数式变量，inc 系列的函数封装了过程，让这些新函数能自增指定的值。
GitHub 上的 ramda 这个库，本质上和课程中讲的东西是一样的，都可以通过一个公式_函数得到一个新的公式_函数。
集合 A 能够通过数学公式映射出一个唯一的结果集合 B。这个公式就可以理解为 add 函数，那么对这个函数进行拓展的话，就能够形成一个新的公式。
为什么要这样做？从公式映射出一个公式是很重要的一个知识点。
定义过程的目标：让开发者在做一件事的时候，尽量少地感知这个过程的存在。如果未来编程的所有工作都能实现这样的需求，那不就很简单了？我们不可能穷举出所有函数，但是如果能够有一个函数能够生成另外一个函数，这样一个创造的能力，可是有无限可能的！
如何能让一个函数只接收一个参数？这就要说说“柯里化”这个关键概念了。
```js
// 正常使用方式
R.add(1, 2);
// 柯里化
R.add(1)(2);
```
函数式编程的基点：希望所有的函数都只接受一个参数。
希望大家能够把这个 add 函数的演进方式写成一篇文章出来，去领悟这背后的思想、目的，从这个需求着手，慢慢领悟到可以用一个函数创造新的函数这种能力。
编程在本质上就是在执行运算，接收数据，进行处理，然后输出。更好的编程就是让用户不需要关注过程，传入数据，获取数据，over。
未来软件的方向：以服务的方式，提供的服务更具体化。
闭包只是函数式编程的一种方法，而函数式编程可以用来解决一些其它编程方法不能解决的问题。
第三方的库、框架都不太需要去读源码，能够通读各个常用库 & 框架的文档，亲手练一遍，就能有非常大的收获了。
老师现在开源的 community 项目，以及之后会开源的 Vue 组件化的项目，都可以当作脚手架来使用，大家可以在这个基础上去修修改改，增加自己想要的功能，做出自己的作品。
- - - -
## 第九课：客户端与web应用的连接
分析初始中间件：所有为Express开发的中间件都必须满足function(req,res,next)这个格式。明白规律后就可以自己开发中间件了。

柯里化：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数——如下（参考资料——函数式编程入门教程——阮一峰）
![](JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/JS%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%AC%94%E8%AE%B0/235486EC-FDA8-4017-91E3-ABADF3C85E9D.png)
- - - -
bin/www 好用嘛？
老师个人不喜欢，推测作者常年在 Linux 下做开发，于是习惯于用 bin 作为启动文件夹。
而在 Node.js 中，老师推荐 `app.js/index.js/server.js`，后面会讲原因。

### 分析中间件
所有的中间件都是下面的模式：
```js
app.use(function(req, res, next) {
    // some code
});
```
下面开始分析中间件。
`var logger = require('morgan');`
morgan 是 package.json 中引入的库。
这些库都安装在 node_modules 之中，项目虽然只引入了几个中间件，但是它们还有各自的依赖，所以查看 node_modules 这个目录的话，会发现里面有很多的文件夹。
查看 morgan 这个库的文件夹，可以发现它本身就是一个标准的 Node.js 项目。文件夹中有 package.json 和 index.js。有了这两个文件，这就是一个独立的项目了。
查看 index.js，里面有 module.exports = morgan。再查看 morgan 这个函数的定义，能够发现它最后有 return logger(req, res, next) {} 这么一句。
所以说为什么 app.js 中是 app.use(logger())？为什么要执行 logger() 这个函数？就是因为 morgan 函数体内返回的是 logger() 这个函数的函数体。
另外要注意，morgan 的启动程序是 index.js，而不是 bin/www，这是比较合适的启动方式。
这就是函数式编程。
这就是中间件，中间件都会返回一个函数，接受 req, res, next 作为参数。
题外话：新加入一个技术团队，第一件要学的事：了解代码规范。

### 继续探讨柯里化
curry 的概念：只传递给函数一部分参数来调用它，让它返回一个（子/嵌套）函数来处理剩余的参数。
数学中函数的组合：y = f(x), z = g(y)，那么 z = g(f(x))。
而在 JavaScript 中，就实现了这种函数的组合，也就是函数式编程（柯里化）。
```js
function addOne(x) {
    return x + 1;
}

function addTwo(x) {
    return x + 2;
}

function add(f, g) {
    return function(x) {
        return f(g(x)); // 大家公认的写法
    }
}
```
add(addOne, addTwo)(1);  addOne 就是 f，addTwo 就是 g
什么是函数式编程？就是定义过程（预定义了整个处理过程），最后只需要传入一个参数即可。定义过程，有些书籍和文章中，也会叫做“预加载“。
函数式编程特点：
> 纯洁，透明：功能很纯粹，传进来的是什么，传出去的就是对应的值。不会出现传入一个值，出现两种不同的结果的情况。  
比如 app.js 中连续的两个 app.use() 分别引入了不同的中间件，两个中间件引入的顺序互换一下，Express 项目的执行结果并不会变化。
```js
var num = 3;

function addOne(x) {
    return x + num;
}

addOne(1); // 4

num = 5;

addOne(1); // 6
```
上面代码里的这个 addOne() 就无法简单地移植到别的地方，因为它还依赖外在的 num 这个变量。这个函数就不纯洁了。
题外话：上节课李想写的函数式编程的文章，里面的加法器不仅能将两个数字相加，还能将两个字符串组合起来。这些都是函数式编程最基本的使用方式，建议大家多动手练练。
PS：后面三节课就要正式进入 Promise 的领域里面。

### 剖析 next
next(new Error('123')) 和 next('123') 有什么区别？由于 next 最终将走到 app.js 的最后一个函数里面，而最后的这个函数，第一行代码是：
`res.locals.message = next.message || err;`

### 讨论 MongoDB API
PostModel.find({}, {}, callback) 和 PostModel.find({}, callback)，两者的执行结果其实是相同的。设计得好的 API，就能够兼顾各种情况。
```
function(req, res) {
    if (err) { res.json { err: err }};
}
```
上面的处理也是完全没问题的，既然不经过 Express 自身的 next，直接传到前端，那么参数中就不需要 next 了。
> 为啥有时候是 return next(err); 有时候是 next(err);？  
如果函数中 next(err) 之后的部分没有代码了，那就不需要手动 return 了，因为执行完这个函数就会进入到 app.js 里的错误处理部分。
否则如果 next(err) 之后还有代码，而自己希望遇到 err 的话就不再执行后面的代码，那么就必须手动 return 一下，来主动控制程序流程了。
此外，如果在这之后还有 next() 语句，那么一个 req 就会有两个 reponse，这就出问题了。
关于 next() 的流程：如果 next() 不带参数，就会继续往下查找匹配的路由。如果是 next(err) 的话，才会交给 app.js 中的错误处理。
题外话：小程序技巧一句话：HTML 放在一个文件中，JS 放在另一个文件中即可。

### 技术选型
喜欢用 Vue 处理前端部分，不想用 EJS，但是 Express.js 能直接将变量传到 EJS 中，如果完全不用 EJS，只用 Vue，Express 和 Vue 该怎么搭配使用比较好？
如果要前后端分离，前端就用 Vue，后端的 Express 就不需要 EJS 了。如果前后端融合的话，就用 Express + EJS 之类的组合就好。
开发公司主页，那就一定要用服务器渲染。如果只是公司内部使用的平台，那就可以用 Vue + Express。